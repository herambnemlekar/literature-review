## Other methods for symbolic representation and planning
1. [Inducing probabilistic context-free grammars for the sequencing of movement primitives](https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8460190)
	- Assumptions: 1) We assume each segment of the observed sequences to be a sample from an underlying library of movement primitives. 2) Any produced sequence has toresult in a continuous trajectory inside the state space. By restricting the operators to only produce valid grammars.
	- Definitions: 1) A probabilistic context-free grammar (PCFG) is a 4-tuple G = (A,V,R,S), where A is a set of terminals, V is a set of non terminals, S is a set of starting symbols and R = {(A,R,ρ)| A∈V} is a set of production rules. 2) Learning formal grammars from sequences of terminalsis referred to as grammar induction.
	- PCFG for movement primitives: 1) Θ is set of primitives and D is set of labelled demonstrations. 2) define the set of terminals as the set of primitives A = Θ i.e. primitives are immutable, implying that the search space consists of grammars that only differ in S, V or R. 3) Each grammar is a node in the grammar space, while the directed edges between nodes are defined by operators. Operators manipulate the rule set R of a grammar G to create a new grammar G′. 4) Posterior optimization- G* = argmax p(G|D) = argmax p(D|G) p(G). This is the total probability of the set of demonstrations D given a grammar G. 5) p(D|G) = ∏ p(d|G). 6) p(d|G)= (1/|parse (d,G)|) ∑_{τ∈parse(d,G)} ∏_{(A,r,ρ)∈τ} ρ. This is the average probability over each tree that produces the demonstartion d from grammar G. 7) Grammar prior is joint distribution over grammar probabilities ρ_G = {ρ_A | A∈V} and grammar structure G_R = {ρ_A | A∈V}. 
	- Traversing grammar space: 1) We define a domain Ω_op for each operator op ∈ O, that op can act on. 2) After creating new grammar G', parameters have to be recomputed using Inside-Outside algorithm. 3) Every sequence produced by G has to guarantee a smooth, continuous trajectory within the statespace of the MPs. We restrict the grammar space G to only contain grammars that fulfill this continuity requirement. The restriction is achieved by limiting the domain Ω_op of each operator, such that if grammar G fulfills the continuity requirement any grammar G′resulting from an application of op on G also fulfills the requirement.
	- Summary: Demonstrations are segmented to get primitives. Primitives are immutable. We start from a grammar prior. Each grammar is defined by terminals (A), non-terminals (V), rules (R) and starting symbols (S). Each rule has productions, each of which is a sequence. We apply operators to rules of the previous grammar to get new grammar. The operators are applied such that the new grammar can fit to all demonstrations. The operator changes the rules and non-terminals such that the new rules have new productions (sequences). The rules define how a tree will expand from the start symbols.

2. [State representation learning for control: An overview](https://arxiv.org/pdf/1802.04181.pdf)
	- 